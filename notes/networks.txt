8-24

The internet is billions of connected computing devices of three types:
	
	Computing Devices:
	Hosts/end systems, they run network apps at internet's "edge"

	Routers:
	Packet switches: forward "packets" between hosts (chunks of data)
	Ex: routers, switches

	Links:
	Communication links (wired and wireless)
	Ex: fiber, copper, radio, satellite
	Transmission rate: bandwith


Networks are a collection of devices, routers, and links, managed by an organization

The internet is essentially a network of networks (Interconnected ISPs)





The internet is also an infrastructure that provides services to applications

Protocols control sending and reciving of messages
Ex: HTTP, ICP, IP, WiFi, 4G, Ethernet

Internet standards
RFC: Request for comments
IETF: Internet Engineering Task Force


Network core consists of interrconnected routers
Ex: local/regional or national/global ISPs (11)



The internet provides a programming interface to distributed applications

Hooks allow sending/reciving of apps to connect to and use internet transport service

Provides service options, similar to postal service



Back to the internet structure:

Connect end systems to edge routers with:
Residential access nets
Institutional acces networks (school, company)
Mobile access networks (WiFi, 4G, 5G)

Tranmission rate and shared/dedicated access among users effect performance





8-26

Frequency division multiplexing (FDM) are different channels transmitting different frequency bands


Acces via cable based: (14)
Hybrid fiber coax (HFC) has up to 1.2 Gbs down, up to 100 Mbps up

Acces via digital subscriber line: (13)
use existing telephone line to central office DSLAM
up to 50 Mbps down, 16 Mbps up



Wireless access networks is shared among multipule end systems and connects them to the router

Wireless local area networks (WLAN) are typically within or around building (100ft)

Wide area celluar access networks are provided by celluar networks, typically 10km radius, slower transmission rate than WLANs


Enterprise networks are operated by companies, universities, etc
Mix of wired, wireless linked technologies, connecting multipule different switches and routers





Host sending function:
takes application message,
breaks into smaller chuncks, known as packets, of length L bits,
transmits packet into access network at link transmission rate R

packet transmission delay = L/R (bits/bits per second)



Links: physical media

bit propagates between transmitter and reciever
the physical link is what lies between transmitter and reciever
guided media is when signals propogate in a solid media (copper, fiber, coax)
unguded media is when signals propogate freely (radio, WiFi)

types of solid media:
twisted pair - two insulated copper wires (Cat 5/6)
coaxial cable - two concentric copper conductors, bidirectional, brodband. multipule frequency channels on cable, 100's Mbps per channel
fiber optic cable - glass fiber carrying light pulses, each pulse being a bit. high speed operation (100's Gbps), low error rate (immune to electromagnetic noise)

types of unguided media:
wireless radio - signal carried in electromagnetic spectrum. can be obstructed by the environment
terrstrial microwave, wireless LAN, wide area celluar, satellite





Packet-switching is when the hosts break application-layer messahes into packets
Transmission delay takes L/R seconds to transmit an L-bit packet at R bps
Store and forward: entire packet must arrive at router before it can be transmitted to the next link
End-end delay: 2L/R(above), assuming zero propagation delay

Packet queuing and loss: if arrival rate to link exceeds the transmission rate of link, packets will queue, waiting to be transmitted on output link OR packets can be dropped if memory buffer in router fills up

Forwarding: local action, move arriving packets from router's input link to appropriate router output link
Routing: global action, determine source to destination paths taken by packets



Circuit switching is an alternative to packet switching where end-end resources are allocated, and reserved for a call between the source and destination
Has dedicated resources, no sharing enables guaranteed performance
Circuit segment idle if not being used by that specific host
Not used that much today, but used in traditional telephone networks


Frequency Division Multiplexing (FDM) is like the way described above

Time Division Multiplexing (TDM) has slots divided by time, each call allocated can transmit at maximum rate of wider freqeucny bands, but only during its time slots






8-30


Packet switching vs Circuit switching

Packet switching allows more users to use the network
Ex: 1 Gb/s, each user has 100Mb/s when active, but only active 10% of the time

Circuit switching would allow up to 10 users
Packet switching could allow 35 users easily, the probability that there are more than 10 active users at a time is less than 0.4%

Packet switchintg is great for "bursty" data, but is also exposed to packet dealy and loss due to buffer overflow




Internet structure:

Hosts connect to internet via access ISPs
Access ISPs are connected to each other, so any two hosts can send packets to each other
Resulting network of networks is very complex, its evolution was driven by economics and national policies

How do ISPs connect to each other?

Connecting each asccess ISP to each other directly doesnt scale well [O(n^2)]

One option is connecting each access ISP to one global transit ISP. Customer and provider ISPs work with each other to accomplish that
There are more than one global ISP however; the market is competitive

Global ISPs connect via an IXP (internet exchange point) or peering link (direct connecting between 2 global ISPs)
Regional ISPs may also arise to connect cunsomer ISPs to Global ISPs

Then Content provider networks (Google, Microsoft) may run their own network 
to bring services and conent close to end users, bypassing tier 1 and even regional ISPs




Packet delay, the four soucres:

Nodal delay = d_proc + d_queue + d_trans + d_prop

nodal processing: check bit errors, determine output link, typically < ms

queueing delay: time waiting at output link for transmission, depends on cogestion level of router

transmission delay: packet length divided by transmission rate (bps) (L/R)

propagation delay: length of physical link divided by propagation speed (2x10^8 meters per second) (d/s)


Throughput: rate at which bits are being sent from sender to reciever

instantaneous: rate at a given point and time
average: rate over longer period of time





8-31

Networks are complex with many pieces
- hosts
- routers
- links of various media
- applications
- protocols
- hardware, software


Layers: each layer implements a service cia its own internal-layer actions. They rely on services provided by layers before
Explicit structure allows identification, relationship of complex system's pieces
Modularization eases maintenance, updating of system
Changes in layer's service implementation is transparent to the rest of the system


Internet Protocol Stack is each layer put together (51)

- Application Layer
Supporting network applications (IMAP, SMTP, HTTP)

- Transport Layer
Process-process data transfer (TCP, UDP)

- Network Layer
Routing of datagrams from source to destination (IP, Routing Protocols)

- Link Layer
Data transfer between neighboring network elements (Ethernet, 802,11, WiFi, PPP)

- Physical Layer
Bits "on the wire"





Internet was not originally designed with much security in mind. It was thought that it would contain a group of mutually trusting users attached to a transparent network
Internet protocl designers have been trying to patch this issue


Malware can get in to a host from:

A virus - self replicating infection by receiving and executing object (EX: email attachment)
A worm - self rplicating infection by passively receiving object that gets itself executed

Spyware malware can record keystrokes, web sites visited, and upload info to a collection site

Infected host can be enrolld in botnet, used for spam or distributed denial of service (DDos) attacks

Denial of Service attackers make resources unavaliable to legitimate traffic by overwhelming the resource with bogus traffic

Packet "sniffing" is reading/recording all packets passing by 

IP spoofing sends packets with a false source address





9-2

Application Layer Chapter


Creating a network app:
- runs of different end systems
- communicates over network

No need to write software for network core devices. They do not run user applications. Putting applications on end systems allows for rapid app development and propagation


Application architectures:
- Client Server (includes data centers/cloud computing)
- Peer to Peer (P2P)
- Hybrid of client and P2P


Client Server
Server:
- always on host
- permenant IP address
- often in data centers, scalable

Client:
- contact and communicate with server
- may be intermittently connected
- may have a dynamic IP address
- do not communicate directly with other clients

Examples: HTTP, IMAP, FTP



Peer to Peer:
- no always on server
- abitrary end systems directly communicate
- peers request service from other peers, provide service in return
- peers are intermittently connected and change IP addresses

Examples: P2P File Sharing



Examples of Hybrid Systems: Skype, Zoom, IM




Process communications
Process: program running within a host

Within a host, two processes communicate using inter process communication

Processes in different hosts communicate by exchanging messages

Client Process: process that initiates communication
Server Process: process that waits to be contacted



Processes send and recieve messages to/from its socket
Socket is similar to a door:
- Sending process shoves message out the door
- Sending process relies on transport infastructure on the other side of the door to deliver the message to the socket at receiving process
- Two sockets involved, one sending one receiving


Addressing processes
Example port numbers:
- HTTP Server: 80
- Mail Server: 25

Application layer protocol:
Defines type of messages exchanged (requests, response)
Defines message syntax
Defines message Semantics


Public Domain (open protocols) defined in RFC'sm everyone has access to protocol definition

Proprietary does not reveal the rules for their protocols (closed protocols)


As it comes to data loss, some apps require 100% reliable data transfer, while some other apps (like audio apps) tolerate some data loss

Some apps require low delay to be effective, so timing is an important variable

Some apps requrie a minimum amount of throughput to be effective


Internet transport protocols services

TCP Service:
- reliable transport
- flow control, sender wont overwhelm reciever
- congestions control, throttle sender when network overloaded
- does not provide timing, minimum throughput guarantee, security
- connection oriented, setup required between client and server processes

UDP Service:
- unreliable data transfer between sending and receiving process
- does not provide reliability, flow control, congestion control, timing, throughput, security, or connection setup


Securing TCP:

Security Socket Layer (SSL):
- provides encrypted TCP connections
- data integrity 
- end point authentication
SSL is implemented in the application layer





Web and HTTP

Web page consists of objects stored on different Web Servers
Objects can be HTML files, Jpg images, java applet, audio file, etc.
Web page is addressed by a URL (protocol -> host name -> path name)

HTTP stands for hypertext transfer protocol
- Is an application layer protocol
- Client/Server model
Client requests, recieves, and displays web objects
Server sends objects in response to requests

HTTP uses TCP
- Client initiates TCP connection to server port 80
- Server accepts
- HTTP messages exchanged between browser and web server
- TCP connection closed

HTTP is stateless, meaning no information is kept on the server's side about past client requests

Persistent HTTP vs Non Persistent HTTP

Non-persistent HTTP only sends one object per TCP connection at a time. To request multipule objects requires multipule connections

Persistent HTTP leaves the TCP connection open after the server already sent the response. Usually the TCP connection will close after a certain time. Minamilizes the amount of RTT's in a transaction between a client and server



HTTP Request Messages, two types:
Request - ASCII (human readable) consists of request line, header lines, carriage return
Response - ASCII (human readable) consists of status line, header lines, data

Maintaining user/server state: cookies
Websites and client browsers use cookies to maintain some state between transactions
Four components of cookies:
- Cookie header line of HTTP response message
- Cookie header line in next HTTP request message
- Cookie file kept on user's host, managed by user's browser
- Back end database at Web Site's server

Web Caches (Proxy Servers)
Satisfy client requests without involving origin server
User configures browser to point to a web cache
Browser sends all HTTP requests to cache
If object is in the cache, cache returns object to the client, else cache requests object from origin server



Email

Three Major Components:
User agents - mail reader, composes edits and reads messages
Mail Servers - contains incoming messages, messaging queue, and SMTP protocol
Simple Mail Transfer Protocol

SMPT
Uses AT port 25
Direct transfering between servers
Three phases of transfer:
- Handshaking, Transfer, Closure
Command/response interaction is like HTTP

HTTP PULL, SMTP PUSH
Single part vs Multi part message
8 bit vs 7 bit

Mail Access Protocols:
Internet Mail Access Protocol (IMAP) - provides retreival, deletion, and folders
HTTP - Web based interface on top of SMTP, the IMAP deals with retrieving message info




Domain Name System (DNS)

Distributed database implemented in the hierarchy of many name servers
Implememnted as application-layer protocol
Hostname to IP address Translation
Host Aliasing
Mail Server Aliasing

Why not centralize DNS?
Single Point of Failure
Traffic Volume
Distant Centralized Database

Cenrtalized doesn't scale well, comcast dns servers alone have 600B queries a day


Hierarchial DNS Database
Root DNS Servers -> Top level domain (split up by .com, .edu, etc) -> Authorative 

Root Servers are an incredibley inportant internet function
Also provide DNSSEC - provides security

ICANN Internet Corporation for Assigned Names and Numbers manages root DNS domain

Iterative queries are considered best practice for DNS queries
SMTP uses TCP
DNS uses TCP and UDP


9-14

Chapter 3 Transport Layer

Sender breaks application messages into segements, passes it down to network layer. When the receiver gets it, reassembles segments and passes it to its application layer

Network layer provides logical communication between hosts

Transport layer provides logical communication between processes


9-16

When UDP clients send UDP segments to the same destination port number at a reciving host, those segments will always be directed to the same socket as the reciving host
However, this is not true for TCP clients. they can direct segments to different sockets

It is possible for two TCP segments with source port 80 to be sent by different processes at the ending host
This is not possible for UDP segments

Why is there UDP?
No connection establishment (No extra RTT delay)
No connection state at sender, reciever (simple and cheap)
Small header size (less bandwith needed)
No congestion control (no speed limit)

UDP is used in:
Streaming Multimedia (loss tolerant, rate sensitive)
DNS Name Queries for fastest service
SNMP

To make UDP reliable, add reliability at the application layer like QUIC, and add cogestion control at the application layer

UDP Checksum's goal is to detect errors in a transmittited segment
Sender treats contents of UDP segment as sequence of 16 bit integers
Checksum addition of segment content, value put in checksum field


Chapter 4 Network Layer

Services and Protocols
Sender rencapsulates segments into datagrams, passes to link layer
Reciever delivers segments to transport layer

In every internet device, there are hosts and routers

Two Key Network Layer Functions
Forwarding: Move packets from a router's input link to appropriate router output link
Routing: Determine the route taken by packets from source to destinations (Routing algorithms)

The data (local) plane determines how a datagram arriving on router input port is forwarded to router output port
The control (network wide) plane determines how a datagram is routed among routers along end to end paths from source to destination


Software Defined Networking (SDN) control plane connects routers and forwards important routing information

Network Layer Service Model
Internet has a best effort service model, no QoS guarantees

Simplicity of mechanisim has allowed internet to be widely adopted
Sufficent provisioning of bandwith allows performance of real time application to be good enough most of the time
Replicated application layer distributed services connecting close to clients networks allow services to be provided from many locations






Book Notes Chapter 3: Transport Layer

Transport Layer provides logical communication between application processes running on different hosts
Network Layer provides logical communication between hosts
Extending the network layers communication from hosts to processes on those hosts is called transport layer multiplexing and demultiplexing

Transport Layer is only implemented in end systems

The internet's Transport Protocols are UDP (User Datagram Protocol) and TCP (Transmission Control Protocol)
UDP provides an unreliable, connectionless service to the application layer
TCP provides a reliable, connection oriented service to the application layer

Transport Layer packets are called segments, Network Layer packets are called datagrams

The Internet's Network Protocol is called IP (Internet Protocol)
IP provides logical communication between hosts with a best-effort delivery service model (meaning it is unreliable)
TCP's reliable service is an example of a service a transport layer protocol can provide that a network layer protocol doesnt already


UDP provides:
Multiplexing/Demultiplexing
Intergrity Checks

TCP provides:
Multiplexing/Demultiplexing
Intergrity Checks
Reliable Data Transfer (making sure all data is delivered and in order):
	- Flow Control
	- Sequence Numbers
	- Acknowledgements
	- Timers
Congestion Control


Multiplexing and Demultiplexing:

Transport Layer Packet will contain a source port # and dest port # (each 16 bits) to direct network packets to the correct port
Port numbers ranging from 0 to 1023 are called well known port numbers and are restricted, meaning they are reserved for well known protocols
EX: HTTP uses port 80, FTP uses port 21
http://www.iana.org [RFC 3232]

UDP Segment includes source port and destination port, TCP includes this information plus source IP and destination IP

Two arriving TCP segments with different source IP addresses or source port numbers will be directed to two different sockets, unlike UDP
EX: Host A and Host B both send a segment to port 80 on Host (Server) C. Transport Layer demultiplexing allows these segments to be sent to unique sockets, while UDP would not
Super useful in cases like web servers, where every client is sending HTTP requests to server port 80


Connectionless Transport: UDP

Reasons one might choose to use UDP instead of TCP:
Bypass congestion control, resulting in quicker sending of segments
Can sacrafice data loss for less delays (TCP continues to send over and over until reliable delivery is achieved)
No handshaking like in TCP, resulting in less delay (biggest reason DNS uses UDP)
Reliable data transfer can be acheived in the application level (EX: Google Chrome's QUIC protocol)
No connection state variables required, reducing delay and segment size
Smaller packet header overhead, TCP has 20 bytes while UDP only has 8

Realtime applications in general do not respond to TCP well due to the above reasons

Examples of some popular internet applications and what they use:

Email 					SMTP 					TCP
Remote Terminal Access 	Telnet					TCP
Web 					HTTP 					TCP
File Transfer 			FTP 					TCP
Remote File Server 		NFS						UDP (usually)
Multimedia 				proprietary (usually)	UDP, sometimes 	TCP
Internet Telephony 		propreitary (usually) 	UDP, sometimes 	TCP
Network Management 		SNMP 					Typically 		UDP
Name Translation 		DNS 					Typically 		UDP


Principles of Reliable Data Transfer

In a reliable data transfer, no data bits are corrupted, lost, or delivered out of order. TCP is an example of a reliable data transfer protocol

Types of RDT protocols:

rdt1.0 - Reliable data transfer over a perfecty reliable channel

rdt2.0 - Reliable data transfer over a channel with bit errors
Uses error detection (via checksums for rdt2.0)
Reciever Feedback via positive acknowledgement (ACK) or negative acknowledgement (NAK), "OK" or "Please repeat that" represented as 0 and 1
Retransmission by sender if it recieves an NAK from the reciever (1)

Reliable data transfer protocols based on transmission are called ARQ (Automatic Repeat reQuest) protocols
Since rdt2.0 sender stops and waits for a reciever response, it is called a stop and wait protocol. During that stopping period it can't even get information from its own application layer

rdt2.0 has a fatal flaw, where is can not handle the errors that could occur if the reciever's acknowledgement packet got corrupted. However rdt2.1 fixes that (but still assumes all packets are not lost)

rdt2.1 - Reliable data transfer over a channel with bit errors (bidirectional)
New data field added to segments called the sequence number
Receiver checks sequence number to see if it is a new transmission or old transmission. With this info, it knows what the sender recieved as its acknowledgement
Reciever will still send a negative acknowledgement for a corrupted packet, however, for an out of order packet, it will send a positive acknowledgement
A sender that recieves dupliate ACKs of the same package will know that the reciever did not recieve the packet they sent after that original ACK

rdt 2.2 - Reliable data transfer over a channel with bit errors (bidirectional)
Reciever now also includes a reciever number in its acknowledgement packets
No longer requires use for NAK. Just send an ACK and the sequence number

rdt3.0 - Reliable data transfer over a channel with bit errors and possible loss bits (bidirectional)
Can be implemented in many ways, in rdt3.0, it is the sender's responsibility
Sender uses its own judgement to choose a time where it will resend a segment if it has not recieved an ACK
This implementation requires a countdown timer that can interrupt a sender after a period of time has elapsed
Sender starts timer for each packet, responds to any timer interrupts, and stops the timer appropriatley 
Rdt3.0 also known as the alternating bit protocol (pg 246 for good diagram)


Rdt3.0 is a functionally correct protocol, however, since its a stop and wait protocol, most of today's high speed networks would not be satisfied with its performance
The utilization of the sender is very low, since it stops and waits between the time it sends its last byte, and the time it recevies an acknowledgement (or timeout). Between then, the propigation delay, process of the reciever, any buffers/delays, and propigation delay back (acknowledgement transmission rate is negligeble) all take place and take up a majority of the time

Pipeling helps this problem, allowing the sender to send multipule packets in a row before it ever gets an acknowledgement back from the reciever
Pipelining has some consequences though, such as:
Range of sequence numbers must be increased 
Sender/reciever may have to buffer more than one packet


Go Back N protocol (GBN):
Sender is allowed to transmit multipule packets before receiving acknowledgements
Restrained to a size of N packets for reasons tied to congestion control
Sequence numbers in a GBN fall into four categories:
Already ACK'd [0-base-1]
Sent but not ACK'd [base-nextseqnum-1]
Usable but not sent [nextseqnum, base+N-1]
Not useable [base+N or greater]

N is refered to as the window size and the GBN protocol itself is called a sliding window protocol

GBN uses cumulative acknowledgements, meaning that if the sender recieves an ACK for the segment with sequence number x, it can assume all segments with sequence numbers less than x have also been recieved. This is because the sender always sends one packet at a time, and the reciever will always just send an ACK for its last successful packet recieved if there is an error (and discards error filled packet, even if its just delivered out of order)



Selective Repeat (SR):

A downside to GBN is that a single segment error can result in many segments having to be redelievred (if the window size and bandwith delay is very high)
SR helps mitigate this, by having the sender retransmit only those specific segments that have errors

Differences between SR and GBN:
SR has logical timers for each individual packet, unline GBN, which just had a timer for its last non-acknowledged packet
If an ACK is recieved in SR, and the sequence number is equal to the current base of the window, the window base is moved forward to the unacknowledged packet with the smallest sequence number
Receiver side will only send packets up to its application layer for up to the lowest unacknowledged sequence number (EX: receiving 3, 4, 5, then 2, it will send once 2 comes in in the order 2 3 4 5)
SR reciever must also send an ACK to the sender even if it falls before the base of the current reciever window (pg 257 for good diagram)
SR protocol must have a windows size that is less than or equal to half of the range of sequence numbers (258)

One last note on the assumption of in order data delievery, sequence numbers must not only be used, but be used correctly in order to assure in order data delivery. This involves an assumption made about a packet's "lifetime" in the network (For example, TCP assumes a packet's maximum lifetime in a network is 3 minutes)

Table 3.1 on pg 260 is a good recap for reliable data transfer terms




Connection Oriented Transport (TCP):

Connection oriented means that two processes must "handshake" before they start transmiting data between each other
TCP provides a full duplex service, data from A to B can flow at the same time as data flows from B to A
TCP is a point to point connection, meaning there is no multicasting (one to many) connections with TCP

The maximum amount of data that can be placed in a segment is called the maximum segment size (MSS)
MSS is usually determined by the largest link layer frame that can be sent by the local host called the maximum transmission unit (MTU)

TCP header field is typically 20 bytes (12 bytes more than UDP header field)
TCP segment includes:
Source port and Dest port #'s (4 bytes)
Sequence number field (4 bytes) and acknowledgment number field (4 bytes) are both used for reliable data transfer procedures
Header length field (4 bit) specifies length of TCP header (needed because sometimes the options field is not present)
Options field is used when the reciever andsender negotiate the MSS 
The flag field contains 6 bits, one for each flag:
	ACK used to indicate whether value in acknowledgement field is valid
	RST, SYN, FIN used for connection setup and tear down
	CWR and ECE are used in congestion control
	The next two bits are not used but are mentioned for some reason
	PSH bit determines whether data is passed to upper layer immediatley
	URG marks the segment as urgent. The location of the last byte of urgent data is determined by the value in the urgent data pointer (4 byte)


When TCP breaks up a file into segments, it gives each segment a sequence number based on the # of byte that segment starts on
EX: file consists of 500,000 bytes, the MSS is 1,000 bytes, the first segment's sequence number is 0 (for illistrative purposes, the starting point is actually randomly assigned), the second is 1000, etc.

As for acknowledgment numbers, the acknowledgement number a server will give a client in its acknowledgement segment is the next sequence number it expects from the client in that client's next segment

TCP uses cumlulative acknowledgements. As for what it does with out of order recieved packets, that is up to the developer implementing TCP. Usually though, they keep the out of order bytes and wait for missing bytes to fill in the gap, to take better advantage of network bandwith


TCP calculates an EstimatedRTT to determine the best values for its timers that maximize data rate and correct lost packet detection
SampleRTT is a value given once each RTT (not once each segment) of a paticular segment's actual RTT

EstimatedRTT = (1 - a) * EstimatedRTT + a * SampleRTT

a is used as a weight variable, the most common value of a being 1/8
This weighted average of SampleRTTs places more weight on recent RTT's than old ones. In stats, this is called an exponential weighted moving average (EWMA)

TCP also calculates a value, DevRTT, fot the deveation of the SampleRTTs

DevRTT = (1 - B) * DevRTT + B * abs(SampleRTT - EstimatedRTT)

DevRTT is a EWMA for the difference between SampleRTT and EstimatedRTT. The larger the variation, the larger the value of DevRTT

TCP's final timeout interval uses these two values to derive its own value

TimeoutInterval = EstimatedRTT + 4 * DevRTT

Before these two values are able to be calculated, the default TimeoutInterval is reccomended to be one second


As for how TCP handles timers, it doesn't have a timer variable for each individual packet, rather it keeps and updates its timer to be associated with the oldest unacknowledged segment


