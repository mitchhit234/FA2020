Data are known facts that can be recorded, and has implicit meaning

Annual size of the global datasphere is growing exponentially

Structed vs unstructed data
Structuring unstructured data could be very benifical


Database is a collection of related data

DBMS is a system that enables users to create and maintain a database (think SSMS)

Database System is the combination of the database, DBMS, and application


A DBMS does many tasks:

Controls Redundancy
Restricting Unauthorized access
Providing Persistent Storage
Efficent Querying Process
Backup and Recovery
Multipule User Interfaces
Representation of Complex Relationships
Integrity Constraints
Interference Actions



Architecture
Lots of systems have the application and DBMS on seperate servers
Some also have an application server between the application and database servers
With an application server, you can store logic that is requested by different types of applications (web browser, iphone app, etc.) Reduces effort of future modifications needed, isolates application to changes on the database



8-31

Phases of Design

Miniworld: What in the real world are we trying to represent with our data?

Requirements Collection and Analysis:
Database Requirements and Functional (App) Requirements



9-2

The domain is the set of atomic values for an attribute A    dom(A)

Examples:
dom(EmplyeeID) = dddddddd  (d stands for digit)
dom(Status) = (Active, Retired, Deceased, Inactive)


Row/tuple:

t = (v1, v2, v3, ... v_n) where each v_i has 1 <= i <= n is NULL or an element of  dom(A_i)


Relation Schema:

R(A1, A2, A3 ... A_n) where a is an attribute name

Ex: AVENGERS(LNAME, FNAME, STATUS, ... ETC)


Relation State:

r(R)

r = (t1, t2, t3, ... t_n) where t is a tuple defined earlier




Characteristics of Relationships:

Ordering of the Tuples:

A relationship is a set of tuples, and sets have no order
Therefore, ordering of tuples make no difference
However, when retriving tuples, its usually good practice to order them in some way

Ordering of the Values in a Tuple

Ordering of values in a Tuple is essential because the spot of the value is how it is coordinated to its attribute
The order of the attributes is not important however, as long as they are matching up to their correct values in the tuple
However, when setting up attributes, usually putting the primary key as the first attribute is the best practice


Values and NULLs in a Tuple

Values in tuples are atomic. NULL is the absence of a value, therefore two tuples who have NULL for the same attribute do not have the same value for that attribute


Constraints

Inherent model-based contrainsts (implicit constraints)
- Domain Constraints (Integers, Chars, Date Format, etc)
within each tuple, the value v of each attribute A must be an atomic value from the domain of A
domains can be defined by data type, data range, or an enumerated list of acceptable values

Schema based constraints (explicit contraints)
- Key constraints, entity integrity constraints, referential integrity constraints
It is important for every tuple to be uniqley identifiable
Superkey - subset of attributes with the property that no two tuples in and relation have the same combination of values
Key - a superkey such that removing attribute A from K makes K not a superkey (a minimal superkey)
Candidate Key - Term for each key of a relation that has more than 1 key
Primary Key - The designated candidate key used to identify tuples
Unique Key - Candidate Key that is not a Primary Key


Integrity Constraints

Databases are only valid is it is in a state that satifies all rules of the Integrity Constrains

Entity Integrity
No Primary Key value can be NULL

Referential Integrity
Given two relations that refer to each either, a Tuple in one relation must refer to an exisiting tuple in another
A set of attributes in R1 is a foregin key of R1 that references R2 if:
- the domain of attributes in the forgeinkey is the same as the domain of the attributes in the Primary Key of R2
- the values of FK in the tuple in R1 occurs as values of the PK for some tuple in R2



9-9 Basic SQL

Attribute Types:
Numeric - INT, FLOAT, DECIMAL(precision,scale)
Character - CHAR, VARCHAR2
Bit String - 00101
Boolen - TRUE, FALSE, UNKNOWN

Date Types:
TIME
DATE
TIMESTAMP



9-11


Everyone different database backend has different techniques for accessing/manipulating data


9-16

Two different ways to look at operations:
Formal - relational algebra
Informal - SQL

Example: Select

lowercase sigma <selection condition>(R) for relational algebra

<selection condition> = <attribute name><comparission operator><value/attr name> for SQL


Projection: reducing the attributes to a subset of R

pi<attribute name>(R) for relational algebra

SELECT <attribute name(s)> FROM (R)


Rename/aliasing

roe(B1,B2,...B_n)(R) 

SELECT A_1 as B_1 FROM R as Q


Union, Intersection, and Minus

R(A_1, A_2, ...A_n) and Q(B_1, B_2, ...B_n)
must be type compatible, must have the same degree and dom(A_i) = dom(B_i)

SELECT * FROM R 
UNION/INTERSECT/MINUS
SELECT * FROM Q


Cartesian Product

Q X R

SELECT * FROM R CROSS JOIN Q
Combine each tuple in R by each one in Q, so that theres Rtuples X Qtuples total tuples


JOIN 

Combining related tuples from TWO relations into a single relation
Tuples with a NULL value for a join condition attribute are dropped

Join selectivity helps evaluate how much a paticular operation will cut down your amount of tuples to your desired tuples

Inner Join - tuples with no match are eliminated
Outer Join - tuples with no match are not eliminated

Right Outer Join - tuples with no match on the right are not eliminiated
Left Outer Join - tuples with no match on the left are not eliminiated
Full Outer Join - tuples with no match on both sides are not eliminated

Outer Union - union between two relations that are not union compatible


Normalization helps out with the design of a database

Bottom Up design: start with attributes, consider relations between them
Top Down design: start grouping attributes by natural relation then decompose the relations

Design Guidelines:
- Clear Semantics of attributes and schemas
- Reduced Redundancy
- Reduced NULL values
- Disallow possible generation of spurious tuples


Normalization is the process of analyzing given relations of a schema, functional dependicies, and primary keys to achieve desirable properties of minimizing redundancy, and minimizing insertion, modification, and deletion anomlities

Denormalization is the process of storing the join of normal form relations as a base relation which is in a lower normal form


1NF has single atomic values, eliminate multivalued attributes, composite attributes, and nested relations
Still subject to insertion, deletion, and modification anomalies

An attribute if relation schema R is a primary attribute of R if it is a member of a candidate key of R

2NF is a 1NF where every non-prime attribute A in R is fully functionally dependent on the primary key of R. This removes any partial functional dependices

3NF is 2NF where transitive functional dependencies are removed

<<<<<<< HEAD
BCNF all non key columns are dependent on the key
=======

Scanner breeaks the test into SQL keywords, attribute names, and relation names
Parser checks query syntax to determine whether query is formatted correctly
Validated checks that all attribute and relation names are valid and semantically meaningful in the context of the database



SQL Is a functional programming language, you tell it to do something and it does that process in whatever way is fastest

SQL queries are broken into query blocks then translated into relational algebra


Project, Select, Rename have unary operators
Union, Intersect, Difference, Joins are Binary



Anomalies:

Getting rid of partial/transitive functional dependencies, and in turn anomolies, is as simple as getting into 4th normal form

Update anomalie: Make it so you only have to change one value to redefine a attribute value (like switching painting to canvas in the homework), because you would have to change painting to homework in each tuple with the anomalie

Deletion anomalie: You unintentionally remove information from the database by removing the last tuple that has that information in it (for example, removing someone from an office building who was the last person in that building, then deletes the building as well)
(If you deleted the one value of tapestry, then you no longer know that tapestry is a media type)




End of Material for Exam 1 (beggining to query blocks 5.1)


Primary Index is an indexing of a key attribute of a physically ordered data file

Clustering Index is an indexing of a non-key attribute of a physically stored data file

Secondary Index is an indexing of indexes of key or non-key attributes of physically ordered or non-orderd data file
>>>>>>> fb3c2179d672095e67a11340980e461e8f74cace
